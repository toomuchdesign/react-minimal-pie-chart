// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Dist bundle is unchanged 1`] = `
"(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.ReactMinimalPieChart = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  var React__default = 'default' in React ? React['default'] : React;

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function round(number) {
    var divisor = 1e14; // 14 decimals

    return Math.round((number + Number.EPSILON) * divisor) / divisor;
  }

  function degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
  }
  function evaluateLabelTextAnchor(_ref) {
    var labelPosition = _ref.labelPosition,
        lineWidth = _ref.lineWidth,
        labelHorizontalShift = _ref.labelHorizontalShift;
    var dx = round(labelHorizontalShift); // Label in the vertical center

    if (dx === 0) {
      return 'middle';
    } // Outward label


    if (labelPosition > 100) {
      return dx > 0 ? 'start' : 'end';
    } // Inward label


    var innerRadius = 100 - lineWidth;

    if (labelPosition < innerRadius) {
      return dx > 0 ? 'end' : 'start';
    } // Overlying label


    return 'middle';
  }
  function valueBetween(value, min, max) {
    if (value > max) return max;
    if (value < min) return min;
    return value;
  }
  function extractPercentage(value, percentage) {
    return value * percentage / 100;
  }
  function bisectorAngle(startAngle, lengthAngle) {
    return startAngle + lengthAngle / 2;
  }
  function shiftVectorAlongAngle(angle, distance) {
    var angleRadians = degreesToRadians(angle);
    return {
      dx: distance * Math.cos(angleRadians),
      dy: distance * Math.sin(angleRadians)
    };
  }
  function isNumber(value) {
    return typeof value === 'number';
  }
  function functionProp(prop, index) {
    return typeof prop === 'function' ? prop(index) : prop;
  }

  function sumValues(data) {
    var sum = 0;

    for (var i = 0; i < data.length; i++) {
      sum += data[i].value;
    }

    return sum;
  } // Append \\"percentage\\", \\"degrees\\" and \\"startOffset\\" into each data entry


  function extendData(_ref) {
    var data = _ref.data,
        totalAngle = _ref.lengthAngle,
        totalValue = _ref.totalValue,
        paddingAngle = _ref.paddingAngle;
    var total = totalValue || sumValues(data);
    var normalizedTotalAngle = valueBetween(totalAngle, -360, 360);
    var numberOfPaddings = Math.abs(normalizedTotalAngle) === 360 ? data.length : data.length - 1;
    var singlePaddingDegrees = Math.abs(paddingAngle) * Math.sign(totalAngle);
    var degreesTakenByPadding = singlePaddingDegrees * numberOfPaddings;
    var degreesTakenByPaths = normalizedTotalAngle - degreesTakenByPadding;
    var lastSegmentEnd = 0; // @NOTE: Shall we evaluate percentage accordingly to dataEntry.value's sign?

    return data.map(function (dataEntry) {
      var valueInPercentage = total === 0 ? 0 : dataEntry.value / total * 100;
      var degrees = extractPercentage(degreesTakenByPaths, valueInPercentage);
      var startOffset = lastSegmentEnd;
      lastSegmentEnd = lastSegmentEnd + degrees + singlePaddingDegrees;
      return _extends({
        percentage: valueInPercentage,
        degrees: degrees,
        startOffset: startOffset
      }, dataEntry);
    });
  }

  function ReactMinimalPieChartLabel(_ref) {
    var data = _ref.data,
        dataIndex = _ref.dataIndex,
        color = _ref.color,
        props = _objectWithoutPropertiesLoose(_ref, [\\"data\\", \\"dataIndex\\", \\"color\\"]);

    return /*#__PURE__*/React__default.createElement(\\"text\\", _extends({
      dominantBaseline: \\"central\\",
      fill: color
    }, props));
  }
  ReactMinimalPieChartLabel.displayName = 'ReactMinimalPieChartLabel';

  function renderLabelItem(providedLabel, labelProps, defaultValue) {
    if (React__default.isValidElement(providedLabel)) {
      return React__default.cloneElement(providedLabel, labelProps);
    }

    var labelValue = defaultValue;

    if (typeof providedLabel === 'function') {
      var label = providedLabel(labelProps);

      if (React__default.isValidElement(label)) {
        return label;
      }

      labelValue = label;
    }

    return /*#__PURE__*/React__default.createElement(ReactMinimalPieChartLabel, labelProps, labelValue);
  }

  function renderLabels(data, props) {
    return data.map(function (dataEntry, index) {
      var _functionProp;

      var segmentsShift = (_functionProp = functionProp(props.segmentsShift, index)) != null ? _functionProp : 0;
      var distanceFromCenter = extractPercentage(props.radius, props.labelPosition) + segmentsShift;
      var startAngle = props.startAngle + dataEntry.startOffset;
      var segmentBisector = bisectorAngle(startAngle, dataEntry.degrees);

      var _shiftVectorAlongAngl = shiftVectorAlongAngle(segmentBisector, distanceFromCenter),
          dx = _shiftVectorAlongAngl.dx,
          dy = _shiftVectorAlongAngl.dy; // This object is passed as props to the \\"label\\" component


      var labelProps = {
        key: \\"label-\\" + (dataEntry.key || index),
        x: props.cx,
        y: props.cy,
        dx: dx,
        dy: dy,
        textAnchor: evaluateLabelTextAnchor({
          labelPosition: props.labelPosition,
          lineWidth: props.lineWidth,
          labelHorizontalShift: dx
        }),
        data: data,
        dataIndex: index,
        color: dataEntry.color,
        style: props.labelStyle
      };
      return props.label && renderLabelItem(props.label, labelProps, dataEntry.value);
    });
  }

  var partialCircle = function partialCircle(cx, cy, r, start, end) {
    var length = end - start;
    if (length === 0) return [];
    var fromX = r * Math.cos(start) + cx;
    var fromY = r * Math.sin(start) + cy;
    var toX = r * Math.cos(end) + cx;
    var toY = r * Math.sin(end) + cy;
    var large = Math.abs(length) <= Math.PI ? '0' : '1';
    var sweep = length < 0 ? '0' : '1';
    return [['M', fromX, fromY], ['A', r, r, 0, large, sweep, toX, toY]];
  };

  var svgPartialCircle = partialCircle;

  function makePathCommands(cx, cy, startAngle, lengthAngle, radius) {
    var patchedLengthAngle = valueBetween(lengthAngle, -359.999, 359.999);
    return svgPartialCircle(cx, cy, // center X and Y
    radius, degreesToRadians(startAngle), degreesToRadians(startAngle + patchedLengthAngle)).map(function (command) {
      return command.join(' ');
    }).join(' ');
  }
  function ReactMinimalPieChartPath(_ref) {
    var cx = _ref.cx,
        cy = _ref.cy,
        lengthAngle = _ref.lengthAngle,
        lineWidth = _ref.lineWidth,
        radius = _ref.radius,
        _ref$shift = _ref.shift,
        shift = _ref$shift === void 0 ? 0 : _ref$shift,
        reveal = _ref.reveal,
        startAngle = _ref.startAngle,
        title = _ref.title,
        props = _objectWithoutPropertiesLoose(_ref, [\\"cx\\", \\"cy\\", \\"lengthAngle\\", \\"lineWidth\\", \\"radius\\", \\"shift\\", \\"reveal\\", \\"startAngle\\", \\"title\\"]);

    var pathRadius = radius - lineWidth / 2; //@NOTE This shift might be rendered as a translation in future

    var _shiftVectorAlongAngl = shiftVectorAlongAngle(bisectorAngle(startAngle, lengthAngle), shift),
        dx = _shiftVectorAlongAngl.dx,
        dy = _shiftVectorAlongAngl.dy;

    var pathCommands = makePathCommands(cx + dx, cy + dy, startAngle, lengthAngle, pathRadius);
    var strokeDasharray;
    var strokeDashoffset; // Animate/hide paths with \\"stroke-dasharray\\" + \\"stroke-dashoffset\\"
    // https://css-tricks.com/svg-line-animation-works/

    if (isNumber(reveal)) {
      var pathLength = degreesToRadians(pathRadius) * lengthAngle;
      strokeDasharray = Math.abs(pathLength);
      strokeDashoffset = strokeDasharray - extractPercentage(strokeDasharray, reveal);
    }

    return /*#__PURE__*/React__default.createElement(\\"path\\", _extends({
      d: pathCommands,
      strokeWidth: lineWidth,
      strokeDasharray: strokeDasharray,
      strokeDashoffset: strokeDashoffset
    }, props), title && /*#__PURE__*/React__default.createElement(\\"title\\", null, title));
  }
  ReactMinimalPieChartPath.displayName = 'ReactMinimalPieChartPath';

  function combineSegmentTransitionsStyle(duration, easing, customStyle) {
    // Merge chart's animation CSS transition with \\"transition\\" found to customStyle
    var transition = \\"stroke-dashoffset \\" + duration + \\"ms \\" + easing;

    if (customStyle && customStyle.transition) {
      transition = transition + \\",\\" + customStyle.transition;
    }

    return {
      transition: transition
    };
  }

  function getRevealValue(props) {
    //@NOTE When animation is on, chart has to be fully revealed when reveal is not set
    if (props.animate && !isNumber(props.reveal)) {
      return 100;
    }

    return props.reveal;
  }

  function makeEventHandler(eventHandler, payload) {
    return eventHandler && function (e) {
      eventHandler(e, payload);
    };
  }

  function renderSegments(data, props, revealOverride) {
    // @NOTE this should go in Path component. Here for performance reasons
    var reveal = revealOverride != null ? revealOverride : getRevealValue(props);
    var radius = props.radius;
    var lineWidth = extractPercentage(radius, props.lineWidth);
    var paths = data.map(function (dataEntry, index) {
      var segmentsStyle = functionProp(props.segmentsStyle, index);
      return /*#__PURE__*/React__default.createElement(ReactMinimalPieChartPath, {
        key: dataEntry.key || index,
        cx: props.cx,
        cy: props.cy,
        startAngle: props.startAngle + dataEntry.startOffset,
        lengthAngle: dataEntry.degrees,
        radius: radius,
        lineWidth: lineWidth,
        reveal: reveal,
        shift: functionProp(props.segmentsShift, index),
        title: dataEntry.title,
        style: Object.assign({}, segmentsStyle, props.animate && combineSegmentTransitionsStyle(props.animationDuration, props.animationEasing, segmentsStyle)),
        stroke: dataEntry.color,
        strokeLinecap: props.rounded ? 'round' : undefined,
        tabIndex: props.segmentsTabIndex,
        fill: \\"none\\",
        onBlur: makeEventHandler(props.onBlur, index),
        onClick: makeEventHandler(props.onClick, index),
        onFocus: makeEventHandler(props.onFocus, index),
        onKeyDown: makeEventHandler(props.onKeyDown, index),
        onMouseOver: makeEventHandler(props.onMouseOver, index),
        onMouseOut: makeEventHandler(props.onMouseOut, index)
      });
    });

    if (props.background) {
      paths.unshift( /*#__PURE__*/React__default.createElement(ReactMinimalPieChartPath, {
        key: \\"bg\\",
        cx: props.cx,
        cy: props.cy,
        startAngle: props.startAngle,
        lengthAngle: props.lengthAngle,
        radius: radius,
        lineWidth: lineWidth,
        stroke: props.background,
        strokeLinecap: props.rounded ? 'round' : undefined,
        fill: \\"none\\"
      }));
    }

    return paths;
  }

  var ReactMinimalPieChart = /*#__PURE__*/function (_Component) {
    _inheritsLoose(ReactMinimalPieChart, _Component);

    function ReactMinimalPieChart(props) {
      var _this;

      _this = _Component.call(this, props) || this;
      _this.revealOverride = void 0;
      _this.animationTimerId = void 0;
      _this.animationRAFId = void 0;

      if (props.animate === true) {
        _this.revealOverride = 0;
      }

      return _this;
    }

    var _proto = ReactMinimalPieChart.prototype;

    _proto.componentDidMount = function componentDidMount() {
      var _this2 = this;

      if (this.props.animate) {
        this.animationTimerId = setTimeout(function () {
          _this2.animationTimerId = null;
          _this2.animationRAFId = requestAnimationFrame(function () {
            _this2.animationRAFId = null;

            _this2.startAnimation();
          });
        });
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this.animationTimerId) {
        clearTimeout(this.animationTimerId);
      }

      if (this.animationRAFId) {
        cancelAnimationFrame(this.animationRAFId);
      }
    };

    _proto.startAnimation = function startAnimation() {
      this.revealOverride = null;
      this.forceUpdate();
    };

    _proto.render = function render() {
      var props = this.props;

      if (props.data === undefined) {
        return null;
      }

      var extendedData = extendData(props);
      return /*#__PURE__*/React__default.createElement(\\"div\\", {
        className: props.className,
        style: props.style
      }, /*#__PURE__*/React__default.createElement(\\"svg\\", {
        viewBox: \\"0 0 \\" + props.viewBoxSize[0] + \\" \\" + props.viewBoxSize[1],
        width: \\"100%\\",
        height: \\"100%\\",
        style: {
          display: 'block'
        }
      }, renderSegments(extendedData, props, this.revealOverride), props.label && renderLabels(extendedData, props), props.injectSvg && props.injectSvg()), props.children);
    };

    return ReactMinimalPieChart;
  }(React.Component);

  ReactMinimalPieChart.displayName = 'ReactMinimalPieChart';
  ReactMinimalPieChart.defaultProps = {
    animate: false,
    animationDuration: 500,
    animationEasing: 'ease-out',
    cx: 50,
    cy: 50,
    label: false,
    labelPosition: 50,
    lengthAngle: 360,
    lineWidth: 100,
    paddingAngle: 0,
    radius: 50,
    rounded: false,
    startAngle: 0,
    viewBoxSize: [100, 100]
  };

  exports.default = ReactMinimalPieChart;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
"
`;
