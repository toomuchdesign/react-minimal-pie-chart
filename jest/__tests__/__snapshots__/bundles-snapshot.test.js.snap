// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Dist bundle is unchanged 1`] = `
"(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.ReactMinimalPieChart = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  var React__default = 'default' in React ? React['default'] : React;

  function degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
  }
  function valueBetween(value, min, max) {
    if (value > max) return max;
    if (value < min) return min;
    return value;
  }
  function extractPercentage(value, percentage) {
    return value * percentage / 100;
  }
  function bisectorAngle(startAngle, lengthAngle) {
    return startAngle + lengthAngle / 2;
  }
  function shiftVectorAlongAngle(angle, distance) {
    var angleRadians = degreesToRadians(angle);
    return {
      dx: distance * Math.cos(angleRadians),
      dy: distance * Math.sin(angleRadians)
    };
  }
  function isNumber(value) {
    return typeof value === 'number';
  }
  function functionProp(prop, payload) {
    return typeof prop === 'function' ? prop(payload) : prop;
  }

  function sumValues(data) {
    var sum = 0;

    for (var i = 0; i < data.length; i++) {
      sum += data[i].value;
    }

    return sum;
  } // Append \\"percentage\\", \\"degrees\\" and \\"startOffset\\" into each data entry


  function extendData(_ref) {
    var data = _ref.data,
        totalAngle = _ref.lengthAngle,
        totalValue = _ref.totalValue,
        paddingAngle = _ref.paddingAngle;
    var total = totalValue || sumValues(data);
    var normalizedTotalAngle = valueBetween(totalAngle, -360, 360);
    var numberOfPaddings = Math.abs(normalizedTotalAngle) === 360 ? data.length : data.length - 1;
    var singlePaddingDegrees = Math.abs(paddingAngle) * Math.sign(totalAngle);
    var degreesTakenByPadding = singlePaddingDegrees * numberOfPaddings;
    var degreesTakenByPaths = normalizedTotalAngle - degreesTakenByPadding;
    var lastSegmentEnd = 0; // @NOTE: Shall we evaluate percentage accordingly to dataEntry.value's sign?

    return data.map(function (dataEntry) {
      var valueInPercentage = total === 0 ? 0 : dataEntry.value / total * 100;
      var degrees = extractPercentage(degreesTakenByPaths, valueInPercentage);
      var startOffset = lastSegmentEnd;
      lastSegmentEnd = lastSegmentEnd + degrees + singlePaddingDegrees;
      return Object.assign({
        percentage: valueInPercentage,
        degrees: degrees,
        startOffset: startOffset
      }, dataEntry);
    });
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function Label(_ref) {
    var data = _ref.data,
        dataIndex = _ref.dataIndex,
        color = _ref.color,
        props = _objectWithoutPropertiesLoose(_ref, [\\"data\\", \\"dataIndex\\", \\"color\\"]);

    return /*#__PURE__*/React__default.createElement(\\"text\\", Object.assign({
      dominantBaseline: \\"central\\",
      fill: color
    }, props));
  }
  Label.displayName = 'ReactMinimalPieChartLabel';

  function round(number) {
    var divisor = 1e14; // 14 decimals

    return Math.round((number + Number.EPSILON) * divisor) / divisor;
  }

  function evaluateTextAnchorPosition(_ref) {
    var labelPosition = _ref.labelPosition,
        lineWidth = _ref.lineWidth,
        labelHorizontalShift = _ref.labelHorizontalShift;
    var dx = round(labelHorizontalShift); // Label in the vertical center

    if (dx === 0) {
      return 'middle';
    } // Outward label


    if (labelPosition > 100) {
      return dx > 0 ? 'start' : 'end';
    } // Inward label


    var innerRadius = 100 - lineWidth;

    if (labelPosition < innerRadius) {
      return dx > 0 ? 'end' : 'start';
    } // Overlying label


    return 'middle';
  }

  function renderLabelElement(renderLabel, labelProps) {
    var label = renderLabel(labelProps);

    if (typeof label === 'string' || typeof label === 'number') {
      return /*#__PURE__*/React__default.createElement(Label, labelProps, label);
    }

    if (React__default.isValidElement(label)) {
      return label;
    }

    return null;
  }

  function renderLabels(data, props) {
    return data.map(function (dataEntry, index) {
      var _functionProp;

      var segmentsShift = (_functionProp = functionProp(props.segmentsShift, index)) != null ? _functionProp : 0;
      var distanceFromCenter = extractPercentage(props.radius, props.labelPosition) + segmentsShift;
      var startAngle = props.startAngle + dataEntry.startOffset;
      var segmentBisector = bisectorAngle(startAngle, dataEntry.degrees);

      var _shiftVectorAlongAngl = shiftVectorAlongAngle(segmentBisector, distanceFromCenter),
          dx = _shiftVectorAlongAngl.dx,
          dy = _shiftVectorAlongAngl.dy; // This object is passed as argument to the \\"label\\" function prop


      var labelProps = {
        key: \\"label-\\" + (dataEntry.key || index),
        x: props.cx,
        y: props.cy,
        dx: dx,
        dy: dy,
        textAnchor: evaluateTextAnchorPosition({
          labelPosition: props.labelPosition,
          lineWidth: props.lineWidth,
          labelHorizontalShift: dx
        }),
        data: data,
        dataIndex: index,
        color: dataEntry.color,
        style: props.labelStyle
      };
      return props.label && renderLabelElement(props.label, labelProps);
    });
  }

  var partialCircle = function partialCircle(cx, cy, r, start, end) {
    var length = end - start;
    if (length === 0) return [];
    var fromX = r * Math.cos(start) + cx;
    var fromY = r * Math.sin(start) + cy;
    var toX = r * Math.cos(end) + cx;
    var toY = r * Math.sin(end) + cy;
    var large = Math.abs(length) <= Math.PI ? '0' : '1';
    var sweep = length < 0 ? '0' : '1';
    return [['M', fromX, fromY], ['A', r, r, 0, large, sweep, toX, toY]];
  };

  var svgPartialCircle = partialCircle;

  function makePathCommands(cx, cy, startAngle, lengthAngle, radius) {
    var patchedLengthAngle = valueBetween(lengthAngle, -359.999, 359.999);
    return svgPartialCircle(cx, cy, // center X and Y
    radius, degreesToRadians(startAngle), degreesToRadians(startAngle + patchedLengthAngle)).map(function (command) {
      return command.join(' ');
    }).join(' ');
  }
  function Path(_ref) {
    var cx = _ref.cx,
        cy = _ref.cy,
        lengthAngle = _ref.lengthAngle,
        lineWidth = _ref.lineWidth,
        radius = _ref.radius,
        _ref$shift = _ref.shift,
        shift = _ref$shift === void 0 ? 0 : _ref$shift,
        reveal = _ref.reveal,
        startAngle = _ref.startAngle,
        title = _ref.title,
        props = _objectWithoutPropertiesLoose(_ref, [\\"cx\\", \\"cy\\", \\"lengthAngle\\", \\"lineWidth\\", \\"radius\\", \\"shift\\", \\"reveal\\", \\"startAngle\\", \\"title\\"]);

    var pathRadius = radius - lineWidth / 2; //@NOTE This shift might be rendered as a translation in future

    var _shiftVectorAlongAngl = shiftVectorAlongAngle(bisectorAngle(startAngle, lengthAngle), shift),
        dx = _shiftVectorAlongAngl.dx,
        dy = _shiftVectorAlongAngl.dy;

    var pathCommands = makePathCommands(cx + dx, cy + dy, startAngle, lengthAngle, pathRadius);
    var strokeDasharray;
    var strokeDashoffset; // Animate/hide paths with \\"stroke-dasharray\\" + \\"stroke-dashoffset\\"
    // https://css-tricks.com/svg-line-animation-works/

    if (isNumber(reveal)) {
      var pathLength = degreesToRadians(pathRadius) * lengthAngle;
      strokeDasharray = Math.abs(pathLength);
      strokeDashoffset = strokeDasharray - extractPercentage(strokeDasharray, reveal);
    }

    return /*#__PURE__*/React__default.createElement(\\"path\\", Object.assign({
      d: pathCommands,
      strokeWidth: lineWidth,
      strokeDasharray: strokeDasharray,
      strokeDashoffset: strokeDashoffset
    }, props), title && /*#__PURE__*/React__default.createElement(\\"title\\", null, title));
  }
  Path.displayName = 'ReactMinimalPieChartPath';

  function combineSegmentTransitionsStyle(duration, easing, customStyle) {
    // Merge chart's animation CSS transition with \\"transition\\" found to customStyle
    var transition = \\"stroke-dashoffset \\" + duration + \\"ms \\" + easing;

    if (customStyle && customStyle.transition) {
      transition = transition + \\",\\" + customStyle.transition;
    }

    return {
      transition: transition
    };
  }

  function getRevealValue(props) {
    //@NOTE When animation is on, chart has to be fully revealed when reveal is not set
    if (props.animate && !isNumber(props.reveal)) {
      return 100;
    }

    return props.reveal;
  }

  function makeEventHandler(eventHandler, payload) {
    return eventHandler && function (e) {
      eventHandler(e, payload);
    };
  }

  function renderSegments(data, props, revealOverride) {
    // @NOTE this should go in Path component. Here for performance reasons
    var reveal = revealOverride != null ? revealOverride : getRevealValue(props);
    var radius = props.radius;
    var lineWidth = extractPercentage(radius, props.lineWidth);
    var paths = data.map(function (dataEntry, index) {
      var segmentsStyle = functionProp(props.segmentsStyle, index);
      return /*#__PURE__*/React__default.createElement(Path, {
        key: dataEntry.key || index,
        cx: props.cx,
        cy: props.cy,
        startAngle: props.startAngle + dataEntry.startOffset,
        lengthAngle: dataEntry.degrees,
        radius: radius,
        lineWidth: lineWidth,
        reveal: reveal,
        shift: functionProp(props.segmentsShift, index),
        title: dataEntry.title,
        style: Object.assign({}, segmentsStyle, props.animate && combineSegmentTransitionsStyle(props.animationDuration, props.animationEasing, segmentsStyle)),
        stroke: dataEntry.color,
        strokeLinecap: props.rounded ? 'round' : undefined,
        tabIndex: props.segmentsTabIndex,
        fill: \\"none\\",
        onBlur: makeEventHandler(props.onBlur, index),
        onClick: makeEventHandler(props.onClick, index),
        onFocus: makeEventHandler(props.onFocus, index),
        onKeyDown: makeEventHandler(props.onKeyDown, index),
        onMouseOver: makeEventHandler(props.onMouseOver, index),
        onMouseOut: makeEventHandler(props.onMouseOut, index)
      });
    });

    if (props.background) {
      paths.unshift( /*#__PURE__*/React__default.createElement(Path, {
        key: \\"bg\\",
        cx: props.cx,
        cy: props.cy,
        startAngle: props.startAngle,
        lengthAngle: props.lengthAngle,
        radius: radius,
        lineWidth: lineWidth,
        stroke: props.background,
        strokeLinecap: props.rounded ? 'round' : undefined,
        fill: \\"none\\"
      }));
    }

    return paths;
  }

  var defaultProps = {
    animate: false,
    animationDuration: 500,
    animationEasing: 'ease-out',
    cx: 50,
    cy: 50,
    data: [],
    labelPosition: 50,
    lengthAngle: 360,
    lineWidth: 100,
    paddingAngle: 0,
    radius: 50,
    rounded: false,
    startAngle: 0,
    viewBoxSize: [100, 100]
  }; // @NOTE excluding some defaultProps entries due to issues on how TS inferres types
  // when optional props with multiple types (eg number | string) are defaulted to a specific type

  function PieChart(props) {
    var _useState = React.useState(props.animate ? 0 : null),
        revealOverride = _useState[0],
        setRevealOverride = _useState[1];

    React.useEffect(function () {
      if (props.animate) {
        return startInitialAnimation();
      }

      function startInitialAnimation() {
        var animationTimerId;
        var animationRAFId;
        animationTimerId = setTimeout(function () {
          animationTimerId = null;
          animationRAFId = requestAnimationFrame(function () {
            animationRAFId = null;
            setRevealOverride(null); // Start animation
          });
        });
        return function () {
          animationTimerId && clearTimeout(animationTimerId);
          animationRAFId && cancelAnimationFrame(animationRAFId);
        };
      }
    }, []);
    var extendedData = extendData(props);
    return /*#__PURE__*/React__default.createElement(\\"div\\", {
      className: props.className,
      style: props.style
    }, /*#__PURE__*/React__default.createElement(\\"svg\\", {
      viewBox: \\"0 0 \\" + props.viewBoxSize[0] + \\" \\" + props.viewBoxSize[1],
      width: \\"100%\\",
      height: \\"100%\\",
      style: {
        display: 'block'
      }
    }, renderSegments(extendedData, props, revealOverride), props.label && renderLabels(extendedData, props), props.injectSvg && props.injectSvg()), props.children);
  }
  PieChart.defaultProps = defaultProps;
  PieChart.displayName = 'ReactMinimalPieChart';

  exports.default = PieChart;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
"
`;
